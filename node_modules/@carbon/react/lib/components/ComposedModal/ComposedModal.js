/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.js');
var React = require('react');
var PropTypes = require('prop-types');
var ModalHeader = require('./ModalHeader.js');
var ModalFooter = require('./ModalFooter.js');
var cx = require('classnames');
var toggleClass = require('../../tools/toggleClass.js');
var requiredIfGivenPropIsTruthy = require('../../prop-types/requiredIfGivenPropIsTruthy.js');
var wrapFocus = require('../../internal/wrapFocus.js');
var usePrefix = require('../../internal/usePrefix.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var cx__default = /*#__PURE__*/_interopDefaultLegacy(cx);

const ModalBody = /*#__PURE__*/React__default["default"].forwardRef(function ModalBody(_ref, ref) {
  let {
    className: customClassName,
    children,
    hasForm,
    hasScrollingContent,
    ...rest
  } = _ref;
  const prefix = usePrefix.usePrefix();
  const contentClass = cx__default["default"]({
    [`${prefix}--modal-content`]: true,
    [`${prefix}--modal-content--with-form`]: hasForm,
    [`${prefix}--modal-scroll-content`]: hasScrollingContent,
    [customClassName]: customClassName
  });
  const hasScrollingContentProps = hasScrollingContent ? {
    tabIndex: 0,
    role: 'region'
  } : {};
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", _rollupPluginBabelHelpers["extends"]({
    className: contentClass
  }, hasScrollingContentProps, rest, {
    ref: ref
  }), children), hasScrollingContent && /*#__PURE__*/React__default["default"].createElement("div", {
    className: `${prefix}--modal-content--overflow-indicator`
  }));
});
ModalBody.propTypes = {
  /**
   * Required props for the accessibility label of the header
   */
  ['aria-label']: requiredIfGivenPropIsTruthy["default"]('hasScrollingContent', PropTypes__default["default"].string),

  /**
   * Specify the content to be placed in the ModalBody
   */
  children: PropTypes__default["default"].node,

  /**
   * Specify an optional className to be added to the Modal Body node
   */
  className: PropTypes__default["default"].string,

  /**
   * Provide whether the modal content has a form element.
   * If `true` is used here, non-form child content should have `bx--modal-content__regular-content` class.
   */
  hasForm: PropTypes__default["default"].bool,

  /**
   * Specify whether the modal contains scrolling content
   */
  hasScrollingContent: PropTypes__default["default"].bool
};
const ComposedModal = /*#__PURE__*/React__default["default"].forwardRef(function ComposedModal(_ref2, ref) {
  let {
    ['aria-labelledby']: ariaLabelledBy,
    ['aria-label']: ariaLabel,
    children,
    className: customClassName,
    containerClassName,
    danger,
    isFullWidth,
    onClose,
    onKeyDown,
    open,
    preventCloseOnClickOutside,
    selectorPrimaryFocus,
    selectorsFloatingMenus,
    size,
    ...rest
  } = _ref2;
  const prefix = usePrefix.usePrefix();
  const [isOpen, setisOpen] = React.useState(open);
  const [prevOpen, setPrevOpen] = React.useState(open);
  const innerModal = React.useRef();
  const button = React.useRef();
  const startSentinel = React.useRef();
  const endSentinel = React.useRef();

  if (open !== prevOpen) {
    setisOpen(open);
    setPrevOpen(open);
  }

  function handleKeyDown(evt) {
    // Esc key
    if (evt.which === 27) {
      closeModal(evt);
    }

    onKeyDown(evt);
  }

  function handleMousedown(evt) {
    if (!innerModal.current.contains(evt.target) && preventCloseOnClickOutside) {
      return;
    }

    if (innerModal.current && !innerModal.current.contains(evt.target)) {
      closeModal(evt);
    }
  }

  function handleBlur(_ref3) {
    let {
      target: oldActiveNode,
      relatedTarget: currentActiveNode
    } = _ref3;

    if (open && currentActiveNode && oldActiveNode) {
      const {
        current: bodyNode
      } = innerModal;
      const {
        current: startSentinelNode
      } = startSentinel;
      const {
        current: endSentinelNode
      } = endSentinel;
      wrapFocus["default"]({
        bodyNode,
        startSentinelNode,
        endSentinelNode,
        currentActiveNode,
        oldActiveNode,
        selectorsFloatingMenus
      });
    }
  }

  function closeModal(evt) {
    if (!onClose || onClose(evt) !== false) {
      setisOpen(false);
    }
  }

  const modalClass = cx__default["default"]({
    [`${prefix}--modal`]: true,
    'is-visible': isOpen,
    [customClassName]: customClassName,
    [`${prefix}--modal--danger`]: danger
  });
  const containerClass = cx__default["default"]({
    [`${prefix}--modal-container`]: true,
    [`${prefix}--modal-container--${size}`]: size,
    [`${prefix}--modal-container--full-width`]: isFullWidth,
    [containerClassName]: containerClassName
  }); // Generate aria-label based on Modal Header label if one is not provided (L253)

  let generatedAriaLabel;
  const childrenWithProps = React__default["default"].Children.toArray(children).map(child => {
    switch (child.type) {
      case React__default["default"].createElement(ModalHeader.ModalHeader).type:
        generatedAriaLabel = child.props.label;
        return /*#__PURE__*/React__default["default"].cloneElement(child, {
          closeModal: closeModal
        });

      case React__default["default"].createElement(ModalFooter.ModalFooter).type:
        return /*#__PURE__*/React__default["default"].cloneElement(child, {
          closeModal: closeModal,
          inputref: button
        });

      default:
        return child;
    }
  });
  React.useEffect(() => {
    if (prevOpen !== isOpen) {
      toggleClass["default"](document.body, `${prefix}--body--with-modal-open`, isOpen);
    }
  });
  React.useEffect(() => {
    return () => toggleClass["default"](document.body, `${prefix}--body--with-modal-open`, false);
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  React.useEffect(() => {
    toggleClass["default"](document.body, `${prefix}--body--with-modal-open`, open);
  }, [open, prefix]);
  React.useEffect(() => {
    const focusButton = focusContainerElement => {
      if (focusContainerElement) {
        const primaryFocusElement = focusContainerElement.querySelector(selectorPrimaryFocus);

        if (primaryFocusElement) {
          primaryFocusElement.focus();
          return;
        }

        if (button.current) {
          button.current.focus();
        }
      }
    };

    if (!open) {
      return;
    }

    if (innerModal.current) {
      focusButton(innerModal.current);
    }
  }, [open, selectorPrimaryFocus]);
  return /*#__PURE__*/React__default["default"].createElement("div", _rollupPluginBabelHelpers["extends"]({}, rest, {
    role: "presentation",
    ref: ref,
    "aria-hidden": !open,
    onBlur: handleBlur,
    onMouseDown: handleMousedown,
    onKeyDown: handleKeyDown,
    className: modalClass
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: containerClass,
    role: "dialog",
    "aria-modal": "true",
    "aria-label": ariaLabel ? ariaLabel : generatedAriaLabel,
    "aria-labelledby": ariaLabelledBy
  }, /*#__PURE__*/React__default["default"].createElement("button", {
    type: "button",
    ref: startSentinel,
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"), /*#__PURE__*/React__default["default"].createElement("div", {
    ref: innerModal,
    className: `${prefix}--modal-container-body`
  }, childrenWithProps), /*#__PURE__*/React__default["default"].createElement("button", {
    type: "button",
    ref: endSentinel,
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel")));
});
ComposedModal.propTypes = {
  /**
   * Specify the aria-label for bx--modal-container
   */
  ['aria-label']: PropTypes__default["default"].string,

  /**
   * Specify the aria-labelledby for bx--modal-container
   */
  ['aria-labelledby']: PropTypes__default["default"].string,

  /**
   * Specify the content to be placed in the ComposedModal
   */
  children: PropTypes__default["default"].node,

  /**
   * Specify an optional className to be applied to the modal root node
   */
  className: PropTypes__default["default"].string,

  /**
   * Specify an optional className to be applied to the modal node
   */
  containerClassName: PropTypes__default["default"].string,

  /**
   * Specify whether the primary button should be replaced with danger button.
   * Note that this prop is not applied if you render primary/danger button by yourself
   */
  danger: PropTypes__default["default"].bool,

  /**
   * Specify whether or not the Modal content should have any inner padding.
   */
  isFullWidth: PropTypes__default["default"].bool,

  /**
   * Specify an optional handler for closing modal.
   * Returning `false` here prevents closing modal.
   */
  onClose: PropTypes__default["default"].func,

  /**
   * Specify an optional handler for the `onKeyDown` event. Called for all
   * `onKeyDown` events that do not close the modal
   */
  onKeyDown: PropTypes__default["default"].func,

  /**
   * Specify whether the Modal is currently open
   */
  open: PropTypes__default["default"].bool,
  preventCloseOnClickOutside: PropTypes__default["default"].bool,

  /**
   * Specify a CSS selector that matches the DOM element that should be
   * focused when the Modal opens
   */
  selectorPrimaryFocus: PropTypes__default["default"].string,

  /**
   * Specify the CSS selectors that match the floating menus
   */
  selectorsFloatingMenus: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),

  /**
   * Specify the size variant.
   */
  size: PropTypes__default["default"].oneOf(['xs', 'sm', 'md', 'lg'])
};
ComposedModal.defaultProps = {
  onKeyDown: () => {},
  selectorPrimaryFocus: '[data-modal-primary-focus]'
};
var ComposedModal$1 = ComposedModal;

exports.ModalBody = ModalBody;
exports["default"] = ComposedModal$1;
