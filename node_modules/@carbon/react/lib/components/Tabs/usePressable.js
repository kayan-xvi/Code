/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

function usePressable(ref) {
  let {
    onPress,
    onPressIn,
    onPressOut,
    onLongPress,
    delayLongPressMs = 500
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const savedOnPress = React.useRef(onPress);
  const savedOnPressIn = React.useRef(onPressIn);
  const savedOnPressOut = React.useRef(onPressOut);
  const savedOnLongPress = React.useRef(onLongPress);
  const [pendingLongPress, setPendingLongPress] = React.useState(false);
  const [longPress, setLongPress] = React.useState(false);
  const state = React.useRef({
    longPress: false
  });
  React.useEffect(() => {
    savedOnPress.current = onPress;
  }, [onPress]);
  React.useEffect(() => {
    savedOnPressIn.current = onPressIn;
  }, [onPressIn]);
  React.useEffect(() => {
    savedOnPressOut.current = onPressOut;
  }, [onPressOut]);
  React.useEffect(() => {
    savedOnLongPress.current = onLongPress;
  }, [onLongPress]);
  React.useEffect(() => {
    const {
      current: element
    } = ref; // Fired when a pointer becomes active buttons state.

    function onPointerDown(event) {
      var _savedOnPressIn$curre;

      setPendingLongPress(true);
      (_savedOnPressIn$curre = savedOnPressIn.current) === null || _savedOnPressIn$curre === void 0 ? void 0 : _savedOnPressIn$curre.call(savedOnPressIn);
      event.preventDefault();
    } // Fired when a pointer is no longer active buttons state.


    function onPointerUp() {
      var _savedOnPressOut$curr;

      setPendingLongPress(false);
      setLongPress(false);
      (_savedOnPressOut$curr = savedOnPressOut.current) === null || _savedOnPressOut$curr === void 0 ? void 0 : _savedOnPressOut$curr.call(savedOnPressOut, state.current);
    } // A browser fires this event if it concludes the pointer
    // will no longer be able to generate events (for example
    // the related device is deactivated).


    function onPointerCancel() {
      var _savedOnPressOut$curr2;

      setPendingLongPress(false);
      setLongPress(false);
      (_savedOnPressOut$curr2 = savedOnPressOut.current) === null || _savedOnPressOut$curr2 === void 0 ? void 0 : _savedOnPressOut$curr2.call(savedOnPressOut);
      state.current.longPress = false;
    } // Fired when a pointer is moved out of the hit test
    // boundaries of an element. For pen devices, this event
    // is fired when the stylus leaves the hover range
    // detectable by the digitizer.


    function onPointerLeave() {
      var _savedOnPressOut$curr3;

      setPendingLongPress(false);
      setLongPress(false);
      (_savedOnPressOut$curr3 = savedOnPressOut.current) === null || _savedOnPressOut$curr3 === void 0 ? void 0 : _savedOnPressOut$curr3.call(savedOnPressOut);
      state.current.longPress = false;
    }

    function onClick() {
      var _savedOnPress$current;

      setLongPress(false);
      setPendingLongPress(false);
      (_savedOnPress$current = savedOnPress.current) === null || _savedOnPress$current === void 0 ? void 0 : _savedOnPress$current.call(savedOnPress, state.current);
      state.current.longPress = false;
    } // Certain devices treat long press events as context menu triggers


    function onContextMenu(event) {
      event.preventDefault();
    }

    element.addEventListener('pointerdown', onPointerDown);
    element.addEventListener('pointerup', onPointerUp);
    element.addEventListener('pointercancel', onPointerCancel);
    element.addEventListener('pointerleave', onPointerLeave);
    element.addEventListener('click', onClick);
    element.addEventListener('contextmenu', onContextMenu);
    return () => {
      element.removeEventListener('pointerdown', onPointerDown);
      element.removeEventListener('pointerup', onPointerUp);
      element.removeEventListener('pointercancel', onPointerCancel);
      element.removeEventListener('pointerleave', onPointerLeave);
      element.removeEventListener('click', onClick);
      element.removeEventListener('contextmenu', onContextMenu);
    };
  }, [ref]);
  React.useEffect(() => {
    if (pendingLongPress) {
      const timeoutId = setTimeout(() => {
        setPendingLongPress(false);
        setLongPress(true);
      }, delayLongPressMs);
      return () => {
        clearTimeout(timeoutId);
      };
    }
  }, [pendingLongPress, delayLongPressMs]);
  React.useEffect(() => {
    if (longPress) {
      var _savedOnLongPress$cur;

      state.current.longPress = true;
      return (_savedOnLongPress$cur = savedOnLongPress.current) === null || _savedOnLongPress$cur === void 0 ? void 0 : _savedOnLongPress$cur.call(savedOnLongPress);
    }
  }, [longPress]);
}

exports.usePressable = usePressable;
