var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// Internal Imports
import * as Tools from '../../tools';
import { ColorLegendType, Events, RenderTypes } from '../../interfaces';
import * as Configuration from '../../configuration';
import { Legend } from './legend';
import { DOMUtils } from '../../services';
// D3 imports
import { axisBottom } from 'd3-axis';
import { scaleBand, scaleLinear } from 'd3-scale';
import { interpolateNumber, quantize } from 'd3-interpolate';
var ColorScaleLegend = /** @class */ (function (_super) {
    __extends(ColorScaleLegend, _super);
    function ColorScaleLegend() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'color-legend';
        _this.renderType = RenderTypes.SVG;
        _this.gradient_id = 'gradient-id-' + Math.floor(Math.random() * 99999999999);
        // Position legend after axis have rendered
        _this.handleAxisCompleteEvent = function (event) {
            var svg = _this.getComponentContainer();
            var width = DOMUtils.getSVGElementSize(svg, {
                useAttrs: true,
            }).width;
            var isDataLoading = Tools.getProperty(_this.getOptions(), 'data', 'loading');
            if (width > Configuration.legend.color.barWidth && !isDataLoading) {
                var title = Tools.getProperty(_this.getOptions(), 'heatmap', 'colorLegend', 'title');
                var cartesianScales = _this.services.cartesianScales;
                // Get axis width & start/end positions
                var mainXScale = cartesianScales.getMainXScale();
                var xDimensions = mainXScale.range();
                // Align legend with the axis
                if (xDimensions[0] > 1) {
                    svg.select('g.legend').attr('transform', "translate(" + xDimensions[0] + ", 0)");
                    if (title) {
                        var textWidth = DOMUtils.getSVGElementSize(svg.select('g.legend-title').select('text'), { useBBox: true }).width;
                        // D3 moves the LEFT y-axis labels by 9
                        var availableSpace = xDimensions[0] - textWidth - 9;
                        // If space is available, align the label with the axis labels
                        if (availableSpace > 1) {
                            svg.select('g.legend-title').attr('transform', "translate(" + availableSpace + ", 0)");
                        }
                        else {
                            // Move the legend down by 16 pixels to display legend text on top
                            svg.select('g.legend').attr('transform', "translate(" + xDimensions[0] + ", 16)");
                            // Align legend title with start of axis
                            svg.select('g.legend-title').attr('transform', "translate(" + xDimensions[0] + ", 0)");
                        }
                    }
                }
            }
            else {
                // Default state
                svg.select('g.legend-title').attr('transform', "translate(0, 0)");
            }
        };
        return _this;
    }
    ColorScaleLegend.prototype.init = function () {
        var eventsFragment = this.services.events;
        // Highlight correct circle on legend item hovers
        eventsFragment.addEventListener(Events.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
    };
    ColorScaleLegend.prototype.render = function (animate) {
        if (animate === void 0) { animate = false; }
        var options = this.getOptions();
        var svg = this.getComponentContainer();
        var width = DOMUtils.getSVGElementSize(svg, {
            useAttrs: true,
        }).width;
        var customColors = Tools.getProperty(options, 'color', 'gradient', 'colors');
        var colorScaleType = Tools.getProperty(options, 'heatmap', 'colorLegend', 'type');
        var colorPairingOption = Tools.getProperty(options, 'color', 'pairing', 'option');
        var title = Tools.getProperty(options, 'heatmap', 'colorLegend', 'title');
        // Clear DOM if loading
        var isDataLoading = Tools.getProperty(this.getOptions(), 'data', 'loading');
        if (isDataLoading) {
            svg.html('');
            return;
        }
        var customColorsEnabled = !Tools.isEmpty(customColors);
        var domain = this.model.getValueDomain();
        var useDefaultBarWidth = !(width <= Configuration.legend.color.barWidth);
        var barWidth = useDefaultBarWidth
            ? Configuration.legend.color.barWidth
            : width;
        var legendGroupElement = DOMUtils.appendOrSelect(svg, 'g.legend');
        var axisElement = DOMUtils.appendOrSelect(legendGroupElement, 'g.legend-axis');
        // Render title if it exists
        if (title) {
            var legendTitleGroup = DOMUtils.appendOrSelect(svg, 'g.legend-title');
            var legendTitle = DOMUtils.appendOrSelect(legendTitleGroup, 'text');
            legendTitle.text(title).attr('dy', '0.7em');
            // Move the legend down by 16 pixels to display legend text on top
            legendGroupElement.attr('transform', "translate(0, 16)");
        }
        // If domain consists of negative and positive values, use diverging palettes
        var colorScheme = domain[0] < 0 && domain[1] > 0 ? 'diverge' : 'mono';
        // Use default color pairing options if not in defined range
        if (colorPairingOption < 1 &&
            colorPairingOption > 4 &&
            colorScheme === 'mono') {
            colorPairingOption = 1;
        }
        else if (colorPairingOption < 1 &&
            colorPairingOption > 2 &&
            colorScheme === 'diverge') {
            colorPairingOption = 1;
        }
        var colorPairing = [];
        // Carbon charts has 11 colors for a single monochromatic palette & 17 for a divergent palette
        var colorGroupingLength = colorScheme === 'diverge' ? 17 : 11;
        if (!customColorsEnabled) {
            // Add class names to list and the amount based on the color scheme
            for (var i = 1; i < colorGroupingLength + 1; i++) {
                colorPairing.push(colorScaleType === ColorLegendType.LINEAR
                    ? "stop-color-" + colorScheme + "-" + colorPairingOption + "-" + i
                    : "fill-" + colorScheme + "-" + colorPairingOption + "-" + i);
            }
        }
        else {
            // Use custom colors
            colorPairing = customColors;
        }
        // Generate equal chunks between range to act as ticks
        var interpolator = interpolateNumber(domain[0], domain[1]);
        var quant = quantize(interpolator, 3);
        // Create scale & ticks
        var linearScale = scaleLinear().domain(domain).range([0, barWidth]);
        var legendAxis = axisBottom(linearScale)
            .tickSize(0)
            .tickValues(quant);
        switch (colorScaleType) {
            case ColorLegendType.LINEAR:
                this.drawLinear(colorPairing, legendGroupElement, barWidth);
                break;
            case ColorLegendType.QUANTIZE:
                var rangeStart = this.drawQuantize(colorPairing, colorScheme, customColorsEnabled, legendGroupElement, barWidth);
                // Using range provided by drawQuantize for alignment purposes
                linearScale.range([rangeStart, barWidth]);
                break;
            default:
                throw Error('Entered color legend type is not supported.');
        }
        // Align axes at the bottom of the rectangle and delete the domain line
        axisElement
            .attr('transform', "translate(0," + Configuration.legend.color.axisYTranslation + ")")
            .call(legendAxis);
        // Remove auto generated axis bottom line
        axisElement.select('.domain').remove();
        // Translate first/last axis tick if barWidth equals chart width
        // Ensures text is not clipped when default bar width (300px) is not used
        axisElement
            .select('g.tick:last-of-type text')
            .style('text-anchor', useDefaultBarWidth ? 'middle' : 'end');
        axisElement
            .select('g.tick:first-of-type text')
            .style('text-anchor', useDefaultBarWidth ? 'middle' : 'start');
    };
    // Renders gradient legend
    ColorScaleLegend.prototype.drawLinear = function (colorPairing, legendGroupElement, barWidth) {
        var stopLengthPercentage = 100 / (colorPairing.length - 1);
        // Generate the gradient
        var linearGradient = DOMUtils.appendOrSelect(legendGroupElement, 'linearGradient');
        // Rendering gradient
        linearGradient
            .attr('id', this.gradient_id + "-legend")
            .selectAll('stop')
            .data(colorPairing)
            .enter()
            .append('stop')
            .attr('offset', function (_, i) { return i * stopLengthPercentage + "%"; })
            .attr('class', function (_, i) { return colorPairing[i]; })
            .attr('stop-color', function (d) { return d; });
        // Create the legend container
        var rectangle = DOMUtils.appendOrSelect(legendGroupElement, 'rect');
        rectangle
            .attr('width', barWidth)
            .attr('height', Configuration.legend.color.barHeight)
            .style('fill', "url(#" + this.gradient_id + "-legend)");
    };
    /**
     * Renders quantized legend
     * @returns number (range start)
     */
    ColorScaleLegend.prototype.drawQuantize = function (colorPairing, colorScheme, customColorsEnabled, legendGroupElement, barWidth) {
        // If divergent && non-custom color, remove 0/white from being displayed
        if (!customColorsEnabled && colorScheme === 'diverge') {
            colorPairing.splice(colorPairing.length / 2, 1);
        }
        var colorScaleBand = scaleBand()
            .domain(colorPairing)
            .range([0, barWidth]);
        // Render the quantized rectangles
        var rectangle = DOMUtils.appendOrSelect(legendGroupElement, 'g.quantized-rect');
        rectangle
            .selectAll('rect')
            .data(colorScaleBand.domain())
            .join('rect')
            .attr('x', function (d) { return colorScaleBand(d); })
            .attr('y', 0)
            .attr('width', Math.max(0, colorScaleBand.bandwidth() - 1))
            .attr('height', Configuration.legend.color.barHeight)
            .attr('class', function (d) { return d; })
            .attr('fill', function (d) { return d; });
        return (!customColorsEnabled && colorScheme) === 'mono'
            ? colorScaleBand.bandwidth() - 1
            : 0;
    };
    ColorScaleLegend.prototype.destroy = function () {
        // Remove legend listeners
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
    };
    return ColorScaleLegend;
}(Legend));
export { ColorScaleLegend };
//# sourceMappingURL=../../../src/components/essentials/color-scale-legend.js.map