var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// Internal Imports
import { Service } from '../service';
import { Events } from './../../interfaces';
// D3 Imports
import { select } from 'd3-selection';
import * as Tools from '../../tools';
// import the settings for the css prefix
import { carbonPrefix } from '../../configuration-non-customizable';
// MISC
import ResizeObserver from 'resize-observer-polyfill';
import domToImage from 'dom-to-image-more';
var CSS_VERIFIER_ELEMENT_CLASSNAME = 'DONT_STYLE_ME_css_styles_verifier';
var DOMUtils = /** @class */ (function (_super) {
    __extends(DOMUtils, _super);
    function DOMUtils(model, services) {
        return _super.call(this, model, services) || this;
    }
    DOMUtils.getHTMLElementSize = function (element) {
        return {
            width: element.clientWidth,
            height: element.clientHeight,
        };
    };
    DOMUtils.getSVGElementSize = function (svgSelector, options) {
        if (options === void 0) { options = {
            useAttrs: false,
            useClientDimensions: false,
            useBBox: false,
            useBoundingRect: false,
        }; }
        if (!svgSelector.attr) {
            svgSelector = select(svgSelector);
        }
        var finalDimensions = {
            width: 0,
            height: 0,
        };
        var validateAndSetDimensions = function (dimensions) {
            if (dimensions) {
                Object.keys(finalDimensions).forEach(function (dimensionKey) {
                    if (dimensions[dimensionKey]) {
                        var dimension = dimensions[dimensionKey];
                        var dimensionNumber = parseFloat(dimension);
                        if (dimension &&
                            dimensionNumber > finalDimensions[dimensionKey] &&
                            ('' + dimension).indexOf('%') === -1) {
                            finalDimensions[dimensionKey] = dimensionNumber;
                        }
                    }
                });
            }
        };
        var attrDimensions = {
            width: svgSelector.attr('width'),
            height: svgSelector.attr('height'),
        };
        var bbox, bboxDimensions, boundingRect, boundingRectDimensions;
        // In many versions of Firefox
        // getBBox will cause an "NSFailure" error
        try {
            bbox = svgSelector.node().getBBox();
            bboxDimensions = {
                width: bbox.width,
                height: bbox.height,
            };
        }
        catch (e) { }
        try {
            boundingRect = svgSelector.node().getBoundingClientRect();
            boundingRectDimensions = {
                width: boundingRect.width,
                height: boundingRect.height,
            };
        }
        catch (e) { }
        var clientDimensions = {
            width: svgSelector.node().clientWidth,
            height: svgSelector.node().clientHeight,
        };
        // If both attribute values are numbers
        // And not percentages or NaN
        if (options) {
            if (options.useAttrs) {
                validateAndSetDimensions(attrDimensions);
                if (finalDimensions.width > 0 && finalDimensions.height > 0) {
                    return finalDimensions;
                }
            }
            if (options.useClientDimensions) {
                validateAndSetDimensions(clientDimensions);
                if (finalDimensions.width > 0 && finalDimensions.height > 0) {
                    return clientDimensions;
                }
            }
            if (options.useBBox) {
                validateAndSetDimensions(bboxDimensions);
                if (finalDimensions.width > 0 && finalDimensions.height > 0) {
                    return bboxDimensions;
                }
            }
            if (options.useBoundingRect) {
                validateAndSetDimensions(boundingRectDimensions);
                if (finalDimensions.width > 0 && finalDimensions.height > 0) {
                    return boundingRectDimensions;
                }
            }
        }
        try {
            var nativeDimensions = {
                width: Tools.getProperty(svgSelector.node(), 'width', 'baseVal', 'value'),
                height: Tools.getProperty(svgSelector.node(), 'height', 'baseVal', 'value'),
            };
            validateAndSetDimensions(nativeDimensions);
        }
        catch (e) {
            validateAndSetDimensions(clientDimensions);
            validateAndSetDimensions(bboxDimensions);
            validateAndSetDimensions(attrDimensions);
        }
        return finalDimensions;
    };
    DOMUtils.appendOrSelect = function (parent, query) {
        var selection = parent.select("" + query);
        if (selection.empty()) {
            // see if there is an id
            var querySections = query.split('#');
            var elementToAppend = void 0;
            var id = void 0;
            // if there is an id
            if (querySections.length === 2) {
                // take out the element to append
                elementToAppend = querySections[0];
                // split it by classes
                querySections = querySections[1].split('.');
                // the first string is the id
                id = querySections[0];
            }
            else {
                querySections = query.split('.');
                elementToAppend = querySections[0];
            }
            return parent
                .append(elementToAppend)
                .attr('id', id)
                .attr('class', querySections.slice(1).join(' '));
        }
        return selection;
    };
    DOMUtils.prototype.init = function () {
        // Add width & height to the chart holder if necessary, and add a classname
        this.styleHolderElement();
        // Initialize chart ID
        this.initializeID();
        this.addMainContainer();
        this.verifyCSSStylesBeingApplied();
        if (this.model.getOptions().resizable) {
            this.addResizeListener();
        }
        this.addHolderListeners();
        this.handleFullscreenChange();
    };
    DOMUtils.prototype.getChartID = function () {
        return this.chartID;
    };
    DOMUtils.prototype.generateElementIDString = function (originalID) {
        return "chart-" + this.chartID + "-" + originalID;
    };
    DOMUtils.prototype.initializeID = function () {
        this.chartID = Math.floor((1 + Math.random()) * 0x1000000000000).toString(16);
    };
    DOMUtils.prototype.addMainContainer = function () {
        var options = this.model.getOptions();
        var chartsprefix = Tools.getProperty(options, 'style', 'prefix');
        var mainContainer = select(this.getHolder())
            .append('div')
            .classed(carbonPrefix + "--" + chartsprefix + "--chart-wrapper", true)
            .attr('id', "chart-" + this.getChartID())
            .style('height', '100%')
            .style('width', '100%');
        mainContainer.append('g').attr('class', CSS_VERIFIER_ELEMENT_CLASSNAME);
        this.mainContainer = mainContainer.node();
    };
    DOMUtils.prototype.update = function () {
        this.styleHolderElement();
    };
    DOMUtils.prototype.styleHolderElement = function () {
        var holderElement = this.getHolder();
        // In order for resize events to not clash with these updates
        // We'll check if the width & height values passed in options
        // Have changed, before setting them to the holder
        var _a = this.model.getOptions(), width = _a.width, height = _a.height, theme = _a.theme;
        if (width !== this.width) {
            // Apply formatted width attribute to chart
            holderElement.style.width = width;
            this.width = width;
        }
        if (height !== this.height) {
            // Apply formatted width attribute to chart
            holderElement.style.height = height;
            this.height = height;
        }
        // Add class to chart holder
        select(this.getHolder())
            .classed(carbonPrefix + "--chart-holder", true)
            .attr('data-carbon-theme', theme);
    };
    DOMUtils.prototype.getHolder = function () {
        return this.model.get('holder');
    };
    DOMUtils.prototype.exportToJPG = function () {
        var self = this;
        var options = this.model.getOptions();
        var holder = this.getHolder();
        var holderSelection = select(holder);
        holderSelection.classed('filled', true);
        domToImage
            .toJpeg(this.getMainContainer(), {
            bgcolor: typeof window !== 'undefined'
                ? window
                    .getComputedStyle(holder)
                    .getPropertyValue('background-color')
                : undefined,
            quality: 1,
            // Remove the toolbar
            filter: function (node) {
                if (node.classList &&
                    node.classList.contains('cds--cc--toolbar')) {
                    return false;
                }
                return true;
            },
        })
            .then(function (dataUrl) {
            var fileName = 'myChart';
            var customFilename = Tools.getProperty(options, 'fileDownload', 'fileName');
            if (typeof customFilename === 'function') {
                fileName = customFilename('jpg');
            }
            self.services.files.downloadImage(dataUrl, fileName + ".jpg");
            holderSelection.classed('filled', false);
        });
    };
    DOMUtils.prototype.exportToPNG = function () {
        var self = this;
        var options = this.model.getOptions();
        var holder = this.getHolder();
        var holderSelection = select(holder);
        holderSelection.classed('filled', true);
        domToImage
            .toPng(this.getMainContainer(), {
            bgcolor: typeof window !== 'undefined'
                ? window
                    .getComputedStyle(holder)
                    .getPropertyValue('background-color')
                : undefined,
            quality: 1,
            // Remove the toolbar
            filter: function (node) {
                if (node.classList &&
                    node.classList.contains('cds--cc--toolbar')) {
                    return false;
                }
                return true;
            },
        })
            .then(function (dataUrl) {
            var fileName = 'myChart';
            var customFilename = Tools.getProperty(options, 'fileDownload', 'fileName');
            if (typeof customFilename === 'function') {
                fileName = customFilename('png');
            }
            self.services.files.downloadImage(dataUrl, fileName + ".png");
            holderSelection.classed('filled', false);
        })
            .catch(function (error) {
            console.error('oops, something went wrong!', error);
        });
    };
    DOMUtils.prototype.toggleFullscreen = function () {
        var holder = this.getHolder();
        var holderSelection = select(holder);
        var isFullScreen = holderSelection.classed('fullscreen');
        if (isFullScreen &&
            (document.fullscreenElement ||
                document['webkitFullscreenElement'] ||
                document['mozFullScreenElement'] ||
                document['msFullscreenElement'])) {
            // Call the correct function depending on the browser
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            else if (document['webkitExitFullscreen']) {
                document['webkitExitFullscreen']();
            }
            else if (document['mozCancelFullScreen']) {
                document['mozCancelFullScreen']();
            }
            else if (document['msExitFullscreen']) {
                document['msExitFullscreen']();
            }
        }
        else {
            // Call the correct function depending on the browser
            if (holder.requestFullscreen) {
                holder.requestFullscreen();
            }
            else if (holder.webkitRequestFullscreen) {
                holder.webkitRequestFullscreen();
            }
            else if (holder.mozRequestFullScreen) {
                holder.mozRequestFullScreen();
            }
            else if (holder.msRequestFullscreen) {
                holder.msRequestFullscreen();
            }
        }
    };
    DOMUtils.prototype.handleFullscreenChange = function () {
        var _this = this;
        document.addEventListener('fullscreenchange', function () {
            var holderSelection = select(_this.getHolder());
            var isFullScreen = holderSelection.classed('fullscreen');
            // Toggle the `fullscreen` classname
            holderSelection.classed('fullscreen', !isFullScreen);
        });
    };
    DOMUtils.prototype.verifyCSSStylesBeingApplied = function () {
        var _this = this;
        // setTimeout is needed here since in `addSVGElement()` we're appending the
        // CSS verifier element, and need to allow some time for it to become available
        // in the DOM
        setTimeout(function () {
            var cssVerifierElement = select(_this.mainContainer)
                .select("g." + CSS_VERIFIER_ELEMENT_CLASSNAME)
                .node();
            var computedStyles = getComputedStyle(cssVerifierElement);
            if (computedStyles.getPropertyValue('overflow') !== 'hidden' ||
                computedStyles.getPropertyValue('opacity') !== '0') {
                console.error('Missing CSS styles for Carbon Charts. Please read the Carbon Charts getting started guide.');
            }
        });
    };
    DOMUtils.prototype.setSVGMaxHeight = function () {
        // if there is a set height on the holder, leave the chart svg height at 100%
        if (!this.model.getOptions().height) {
            var chartHeight = DOMUtils.getSVGElementSize(select(this.mainContainer), { useBBox: true }).height;
            var chartSVGSelector = select(this.mainContainer).attr('class');
            var children = select(this.mainContainer).selectAll("." + chartSVGSelector + " > svg");
            // get the height of the children SVGs (spacers, titles, etc)
            var childrenHeight_1 = 0;
            children.nodes().forEach(function (childSVG) {
                childrenHeight_1 += Number(DOMUtils.getSVGElementSize(select(childSVG), {
                    useBBox: true,
                }).height);
            });
            // set the chart svg height to the children height
            // forcing the chart not to take up any more space than it requires
            childrenHeight_1 <= chartHeight
                ? select(this.mainContainer).attr('height', childrenHeight_1)
                : select(this.mainContainer).attr('height', '100%');
        }
    };
    DOMUtils.prototype.getMainContainer = function () {
        return this.mainContainer;
    };
    DOMUtils.prototype.addHolderListeners = function () {
        var _this = this;
        var holder = this.getHolder();
        if (!holder) {
            return;
        }
        select(holder)
            .on('mouseover', function () {
            // Dispatch event
            _this.services.events.dispatchEvent(Events.Chart.MOUSEOVER);
        })
            .on('mouseout', function () {
            // Dispatch event
            _this.services.events.dispatchEvent(Events.Chart.MOUSEOUT);
        });
    };
    DOMUtils.prototype.addResizeListener = function () {
        var _this = this;
        var holder = this.getHolder();
        if (!holder) {
            return;
        }
        // Grab current dimensions of the chart holder
        var containerWidth = holder.clientWidth;
        var containerHeight = holder.clientHeight;
        // The resize callback function
        var resizeCallback = Tools.debounce(function (entries, observer) {
            if (!holder) {
                return;
            }
            if (Math.abs(containerWidth - holder.clientWidth) > 1 ||
                Math.abs(containerHeight - holder.clientHeight) > 1) {
                containerWidth = holder.clientWidth;
                containerHeight = holder.clientHeight;
                _this.services.events.dispatchEvent(Events.Chart.RESIZE);
            }
        }, 12.5);
        // Observe the behaviour of resizing on the holder
        var resizeObserver = new ResizeObserver(resizeCallback);
        resizeObserver.observe(holder);
    };
    return DOMUtils;
}(Service));
export { DOMUtils };
//# sourceMappingURL=../../../src/services/essentials/dom-utils.js.map